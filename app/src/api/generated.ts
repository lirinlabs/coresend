/**
 * Generated by orval v8.4.1 ðŸº
 * Do not edit manually.
 * CoreSend API
 * Temporary email service with identity-based authentication using BIP39 mnemonics
 * OpenAPI spec version: 1.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

export interface ApiDeleteResponse {
  count?: number;
  deleted?: boolean;
  id?: string;
}

export interface ApiEmailResponse {
  body?: string;
  from?: string;
  id?: string;
  received_at?: string;
  subject?: string;
  to?: string[];
}

export type ApiErrorDetailsDetails = { [key: string]: unknown };

export interface ApiErrorDetails {
  code?: string;
  details?: ApiErrorDetailsDetails;
  message?: string;
}

export interface ApiErrorResponse {
  error?: ApiErrorDetails;
}

export type ApiHealthResponseServices = {[key: string]: string};

export interface ApiHealthResponse {
  services?: ApiHealthResponseServices;
  status?: string;
}

export interface ApiInboxResponse {
  address?: string;
  count?: number;
  email?: string;
  emails?: ApiEmailResponse[];
}

export interface ApiRegisterResponse {
  address?: string;
  expires_in?: number;
  registered?: boolean;
}

/**
 * Check API and services health status
 * @summary Health check
 */
export type getApiHealthResponse200 = {
  data: ApiHealthResponse
  status: 200
}

export type getApiHealthResponseSuccess = (getApiHealthResponse200) & {
  headers: Headers;
};
;

export type getApiHealthResponse = (getApiHealthResponseSuccess)

export const getGetApiHealthUrl = () => {


  

  return `/api/health`
}

export const getApiHealth = async ( options?: RequestInit): Promise<getApiHealthResponse> => {
  
  const res = await fetch(getGetApiHealthUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiHealthResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiHealthResponse
}
  




export const getGetApiHealthInfiniteQueryKey = () => {
    return [
    'infinite', `/api/health`
    ] as const;
    }

export const getGetApiHealthQueryKey = () => {
    return [
    `/api/health`
    ] as const;
    }

    
export const getGetApiHealthInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getApiHealth>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiHealthInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiHealth>>> = ({ signal }) => getApiHealth({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiHealthInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getApiHealth>>>
export type GetApiHealthInfiniteQueryError = unknown


export function useGetApiHealthInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiHealth>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiHealth>>,
          TError,
          Awaited<ReturnType<typeof getApiHealth>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiHealthInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiHealth>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiHealth>>,
          TError,
          Awaited<ReturnType<typeof getApiHealth>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiHealthInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiHealth>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health check
 */

export function useGetApiHealthInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiHealth>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiHealthInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetApiHealthQueryOptions = <TData = Awaited<ReturnType<typeof getApiHealth>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiHealth>>> = ({ signal }) => getApiHealth({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getApiHealth>>>
export type GetApiHealthQueryError = unknown


export function useGetApiHealth<TData = Awaited<ReturnType<typeof getApiHealth>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiHealth>>,
          TError,
          Awaited<ReturnType<typeof getApiHealth>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiHealth<TData = Awaited<ReturnType<typeof getApiHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiHealth>>,
          TError,
          Awaited<ReturnType<typeof getApiHealth>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiHealth<TData = Awaited<ReturnType<typeof getApiHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health check
 */

export function useGetApiHealth<TData = Awaited<ReturnType<typeof getApiHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiHealthQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Delete all emails for a specific address
 * @summary Clear entire inbox
 */
export type deleteApiInboxResponse200 = {
  data: ApiDeleteResponse
  status: 200
}

export type deleteApiInboxResponse400 = {
  data: ApiErrorResponse
  status: 400
}

export type deleteApiInboxResponse500 = {
  data: ApiErrorResponse
  status: 500
}

export type deleteApiInboxResponseSuccess = (deleteApiInboxResponse200) & {
  headers: Headers;
};
export type deleteApiInboxResponseError = (deleteApiInboxResponse400 | deleteApiInboxResponse500) & {
  headers: Headers;
};

export type deleteApiInboxResponse = (deleteApiInboxResponseSuccess | deleteApiInboxResponseError)

export const getDeleteApiInboxUrl = () => {


  

  return `/api/inbox`
}

export const deleteApiInbox = async ( options?: RequestInit): Promise<deleteApiInboxResponse> => {
  
  const res = await fetch(getDeleteApiInboxUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteApiInboxResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteApiInboxResponse
}
  



export const getDeleteApiInboxMutationOptions = <TError = ApiErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiInbox>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiInbox>>, TError,void, TContext> => {

const mutationKey = ['deleteApiInbox'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiInbox>>, void> = () => {
          

          return  deleteApiInbox(fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiInboxMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiInbox>>>
    
    export type DeleteApiInboxMutationError = ApiErrorResponse

    /**
 * @summary Clear entire inbox
 */
export const useDeleteApiInbox = <TError = ApiErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiInbox>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiInbox>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getDeleteApiInboxMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve all emails for a specific address
 * @summary Get inbox emails
 */
export type getApiInboxAddressResponse200 = {
  data: ApiInboxResponse
  status: 200
}

export type getApiInboxAddressResponse400 = {
  data: ApiErrorResponse
  status: 400
}

export type getApiInboxAddressResponse500 = {
  data: ApiErrorResponse
  status: 500
}

export type getApiInboxAddressResponseSuccess = (getApiInboxAddressResponse200) & {
  headers: Headers;
};
export type getApiInboxAddressResponseError = (getApiInboxAddressResponse400 | getApiInboxAddressResponse500) & {
  headers: Headers;
};

export type getApiInboxAddressResponse = (getApiInboxAddressResponseSuccess | getApiInboxAddressResponseError)

export const getGetApiInboxAddressUrl = (address: string,) => {


  

  return `/api/inbox/${address}`
}

export const getApiInboxAddress = async (address: string, options?: RequestInit): Promise<getApiInboxAddressResponse> => {
  
  const res = await fetch(getGetApiInboxAddressUrl(address),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiInboxAddressResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiInboxAddressResponse
}
  




export const getGetApiInboxAddressInfiniteQueryKey = (address: string,) => {
    return [
    'infinite', `/api/inbox/${address}`
    ] as const;
    }

export const getGetApiInboxAddressQueryKey = (address: string,) => {
    return [
    `/api/inbox/${address}`
    ] as const;
    }

    
export const getGetApiInboxAddressInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getApiInboxAddress>>>, TError = ApiErrorResponse>(address: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiInboxAddress>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiInboxAddressInfiniteQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiInboxAddress>>> = ({ signal }) => getApiInboxAddress(address, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiInboxAddress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiInboxAddressInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getApiInboxAddress>>>
export type GetApiInboxAddressInfiniteQueryError = ApiErrorResponse


export function useGetApiInboxAddressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiInboxAddress>>>, TError = ApiErrorResponse>(
 address: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiInboxAddress>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiInboxAddress>>,
          TError,
          Awaited<ReturnType<typeof getApiInboxAddress>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiInboxAddressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiInboxAddress>>>, TError = ApiErrorResponse>(
 address: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiInboxAddress>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiInboxAddress>>,
          TError,
          Awaited<ReturnType<typeof getApiInboxAddress>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiInboxAddressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiInboxAddress>>>, TError = ApiErrorResponse>(
 address: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiInboxAddress>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get inbox emails
 */

export function useGetApiInboxAddressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiInboxAddress>>>, TError = ApiErrorResponse>(
 address: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiInboxAddress>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiInboxAddressInfiniteQueryOptions(address,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetApiInboxAddressQueryOptions = <TData = Awaited<ReturnType<typeof getApiInboxAddress>>, TError = ApiErrorResponse>(address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiInboxAddress>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiInboxAddressQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiInboxAddress>>> = ({ signal }) => getApiInboxAddress(address, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiInboxAddress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiInboxAddressQueryResult = NonNullable<Awaited<ReturnType<typeof getApiInboxAddress>>>
export type GetApiInboxAddressQueryError = ApiErrorResponse


export function useGetApiInboxAddress<TData = Awaited<ReturnType<typeof getApiInboxAddress>>, TError = ApiErrorResponse>(
 address: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiInboxAddress>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiInboxAddress>>,
          TError,
          Awaited<ReturnType<typeof getApiInboxAddress>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiInboxAddress<TData = Awaited<ReturnType<typeof getApiInboxAddress>>, TError = ApiErrorResponse>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiInboxAddress>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiInboxAddress>>,
          TError,
          Awaited<ReturnType<typeof getApiInboxAddress>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiInboxAddress<TData = Awaited<ReturnType<typeof getApiInboxAddress>>, TError = ApiErrorResponse>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiInboxAddress>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get inbox emails
 */

export function useGetApiInboxAddress<TData = Awaited<ReturnType<typeof getApiInboxAddress>>, TError = ApiErrorResponse>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiInboxAddress>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiInboxAddressQueryOptions(address,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Delete a specific email by ID for an address
 * @summary Delete single email
 */
export type deleteApiInboxAddressEmailIdResponse200 = {
  data: ApiDeleteResponse
  status: 200
}

export type deleteApiInboxAddressEmailIdResponse400 = {
  data: ApiErrorResponse
  status: 400
}

export type deleteApiInboxAddressEmailIdResponse500 = {
  data: ApiErrorResponse
  status: 500
}

export type deleteApiInboxAddressEmailIdResponseSuccess = (deleteApiInboxAddressEmailIdResponse200) & {
  headers: Headers;
};
export type deleteApiInboxAddressEmailIdResponseError = (deleteApiInboxAddressEmailIdResponse400 | deleteApiInboxAddressEmailIdResponse500) & {
  headers: Headers;
};

export type deleteApiInboxAddressEmailIdResponse = (deleteApiInboxAddressEmailIdResponseSuccess | deleteApiInboxAddressEmailIdResponseError)

export const getDeleteApiInboxAddressEmailIdUrl = (address: string,
    emailId: string,) => {


  

  return `/api/inbox/${address}/${emailId}`
}

export const deleteApiInboxAddressEmailId = async (address: string,
    emailId: string, options?: RequestInit): Promise<deleteApiInboxAddressEmailIdResponse> => {
  
  const res = await fetch(getDeleteApiInboxAddressEmailIdUrl(address,emailId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteApiInboxAddressEmailIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteApiInboxAddressEmailIdResponse
}
  



export const getDeleteApiInboxAddressEmailIdMutationOptions = <TError = ApiErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiInboxAddressEmailId>>, TError,{address: string;emailId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiInboxAddressEmailId>>, TError,{address: string;emailId: string}, TContext> => {

const mutationKey = ['deleteApiInboxAddressEmailId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiInboxAddressEmailId>>, {address: string;emailId: string}> = (props) => {
          const {address,emailId} = props ?? {};

          return  deleteApiInboxAddressEmailId(address,emailId,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiInboxAddressEmailIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiInboxAddressEmailId>>>
    
    export type DeleteApiInboxAddressEmailIdMutationError = ApiErrorResponse

    /**
 * @summary Delete single email
 */
export const useDeleteApiInboxAddressEmailId = <TError = ApiErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiInboxAddressEmailId>>, TError,{address: string;emailId: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiInboxAddressEmailId>>,
        TError,
        {address: string;emailId: string},
        TContext
      > => {
      return useMutation(getDeleteApiInboxAddressEmailIdMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve a specific email by ID for an address
 * @summary Get single email
 */
export type getApiInboxAddressEmailIdResponse200 = {
  data: ApiEmailResponse
  status: 200
}

export type getApiInboxAddressEmailIdResponse400 = {
  data: ApiErrorResponse
  status: 400
}

export type getApiInboxAddressEmailIdResponse404 = {
  data: ApiErrorResponse
  status: 404
}

export type getApiInboxAddressEmailIdResponse500 = {
  data: ApiErrorResponse
  status: 500
}

export type getApiInboxAddressEmailIdResponseSuccess = (getApiInboxAddressEmailIdResponse200) & {
  headers: Headers;
};
export type getApiInboxAddressEmailIdResponseError = (getApiInboxAddressEmailIdResponse400 | getApiInboxAddressEmailIdResponse404 | getApiInboxAddressEmailIdResponse500) & {
  headers: Headers;
};

export type getApiInboxAddressEmailIdResponse = (getApiInboxAddressEmailIdResponseSuccess | getApiInboxAddressEmailIdResponseError)

export const getGetApiInboxAddressEmailIdUrl = (address: string,
    emailId: string,) => {


  

  return `/api/inbox/${address}/${emailId}`
}

export const getApiInboxAddressEmailId = async (address: string,
    emailId: string, options?: RequestInit): Promise<getApiInboxAddressEmailIdResponse> => {
  
  const res = await fetch(getGetApiInboxAddressEmailIdUrl(address,emailId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getApiInboxAddressEmailIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getApiInboxAddressEmailIdResponse
}
  




export const getGetApiInboxAddressEmailIdInfiniteQueryKey = (address: string,
    emailId: string,) => {
    return [
    'infinite', `/api/inbox/${address}/${emailId}`
    ] as const;
    }

export const getGetApiInboxAddressEmailIdQueryKey = (address: string,
    emailId: string,) => {
    return [
    `/api/inbox/${address}/${emailId}`
    ] as const;
    }

    
export const getGetApiInboxAddressEmailIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>>, TError = ApiErrorResponse>(address: string,
    emailId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiInboxAddressEmailIdInfiniteQueryKey(address,emailId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>> = ({ signal }) => getApiInboxAddressEmailId(address,emailId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address && emailId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiInboxAddressEmailIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>>
export type GetApiInboxAddressEmailIdInfiniteQueryError = ApiErrorResponse


export function useGetApiInboxAddressEmailIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiInboxAddressEmailId>>,
          TError,
          Awaited<ReturnType<typeof getApiInboxAddressEmailId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiInboxAddressEmailIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiInboxAddressEmailId>>,
          TError,
          Awaited<ReturnType<typeof getApiInboxAddressEmailId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiInboxAddressEmailIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get single email
 */

export function useGetApiInboxAddressEmailIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiInboxAddressEmailIdInfiniteQueryOptions(address,emailId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetApiInboxAddressEmailIdQueryOptions = <TData = Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError = ApiErrorResponse>(address: string,
    emailId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiInboxAddressEmailIdQueryKey(address,emailId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>> = ({ signal }) => getApiInboxAddressEmailId(address,emailId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address && emailId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiInboxAddressEmailIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>>
export type GetApiInboxAddressEmailIdQueryError = ApiErrorResponse


export function useGetApiInboxAddressEmailId<TData = Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiInboxAddressEmailId>>,
          TError,
          Awaited<ReturnType<typeof getApiInboxAddressEmailId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiInboxAddressEmailId<TData = Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiInboxAddressEmailId>>,
          TError,
          Awaited<ReturnType<typeof getApiInboxAddressEmailId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiInboxAddressEmailId<TData = Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get single email
 */

export function useGetApiInboxAddressEmailId<TData = Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiInboxAddressEmailId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiInboxAddressEmailIdQueryOptions(address,emailId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Register a derived address to actively receive emails for the next 24 hours
 * @summary Register address for inbound mail
 */
export type postApiRegisterAddressResponse200 = {
  data: ApiRegisterResponse
  status: 200
}

export type postApiRegisterAddressResponse400 = {
  data: ApiErrorResponse
  status: 400
}

export type postApiRegisterAddressResponse500 = {
  data: ApiErrorResponse
  status: 500
}

export type postApiRegisterAddressResponseSuccess = (postApiRegisterAddressResponse200) & {
  headers: Headers;
};
export type postApiRegisterAddressResponseError = (postApiRegisterAddressResponse400 | postApiRegisterAddressResponse500) & {
  headers: Headers;
};

export type postApiRegisterAddressResponse = (postApiRegisterAddressResponseSuccess | postApiRegisterAddressResponseError)

export const getPostApiRegisterAddressUrl = (address: string,) => {


  

  return `/api/register/${address}`
}

export const postApiRegisterAddress = async (address: string, options?: RequestInit): Promise<postApiRegisterAddressResponse> => {
  
  const res = await fetch(getPostApiRegisterAddressUrl(address),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postApiRegisterAddressResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postApiRegisterAddressResponse
}
  



export const getPostApiRegisterAddressMutationOptions = <TError = ApiErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiRegisterAddress>>, TError,{address: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiRegisterAddress>>, TError,{address: string}, TContext> => {

const mutationKey = ['postApiRegisterAddress'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiRegisterAddress>>, {address: string}> = (props) => {
          const {address} = props ?? {};

          return  postApiRegisterAddress(address,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiRegisterAddressMutationResult = NonNullable<Awaited<ReturnType<typeof postApiRegisterAddress>>>
    
    export type PostApiRegisterAddressMutationError = ApiErrorResponse

    /**
 * @summary Register address for inbound mail
 */
export const usePostApiRegisterAddress = <TError = ApiErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiRegisterAddress>>, TError,{address: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiRegisterAddress>>,
        TError,
        {address: string},
        TContext
      > => {
      return useMutation(getPostApiRegisterAddressMutationOptions(options), queryClient);
    }
