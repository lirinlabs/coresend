/**
 * Generated by orval v8.4.1 ðŸº
 * Do not edit manually.
 * CoreSend API
 * Temporary email service with identity-based authentication using BIP39 mnemonics
 * OpenAPI spec version: 1.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

export interface ApiDeleteResponse {
  count?: number;
  deleted?: boolean;
  id?: string;
}

export interface ApiEmailResponse {
  body?: string;
  from?: string;
  id: string;
  received_at?: string;
  subject?: string;
  to?: string[];
}

export type ApiErrorDetailsDetails = { [key: string]: unknown };

export interface ApiErrorDetails {
  code?: string;
  details?: ApiErrorDetailsDetails;
  message?: string;
}

export interface ApiErrorResponse {
  error?: ApiErrorDetails;
}

export type ApiHealthResponseServices = {[key: string]: string};

export interface ApiHealthResponse {
  services?: ApiHealthResponseServices;
  status?: string;
}

export interface ApiInboxResponse {
  address?: string;
  count?: number;
  email?: string;
  emails?: ApiEmailResponse[];
}

export interface ApiRegisterResponse {
  address: string;
  expires_in: number;
  registered: boolean;
}

/**
 * Check API and services health status
 * @summary Health check
 */
export type healthCheckResponse200 = {
  data: ApiHealthResponse
  status: 200
}

export type healthCheckResponse503 = {
  data: ApiErrorResponse
  status: 503
}

export type healthCheckResponseSuccess = (healthCheckResponse200) & {
  headers: Headers;
};
export type healthCheckResponseError = (healthCheckResponse503) & {
  headers: Headers;
};

export type healthCheckResponse = (healthCheckResponseSuccess | healthCheckResponseError)

export const getHealthCheckUrl = () => {


  

  return `/api/health`
}

export const healthCheck = async ( options?: RequestInit): Promise<healthCheckResponse> => {
  
  const res = await fetch(getHealthCheckUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: healthCheckResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as healthCheckResponse
}
  




export const getHealthCheckInfiniteQueryKey = () => {
    return [
    'infinite', `/api/health`
    ] as const;
    }

export const getHealthCheckQueryKey = () => {
    return [
    `/api/health`
    ] as const;
    }

    
export const getHealthCheckInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ApiErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckInfiniteQueryError = ApiErrorResponse


export function useHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ApiErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ApiErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ApiErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health check
 */

export function useHealthCheckInfinite<TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>, TError = ApiErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof healthCheck>>, TError = ApiErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckQueryError = ApiErrorResponse


export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = ApiErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = ApiErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = ApiErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health check
 */

export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = ApiErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Delete all emails for a specific address
 * @summary Clear entire inbox
 */
export type clearInboxResponse200 = {
  data: ApiDeleteResponse
  status: 200
}

export type clearInboxResponse400 = {
  data: ApiErrorResponse
  status: 400
}

export type clearInboxResponse500 = {
  data: ApiErrorResponse
  status: 500
}

export type clearInboxResponseSuccess = (clearInboxResponse200) & {
  headers: Headers;
};
export type clearInboxResponseError = (clearInboxResponse400 | clearInboxResponse500) & {
  headers: Headers;
};

export type clearInboxResponse = (clearInboxResponseSuccess | clearInboxResponseError)

export const getClearInboxUrl = (address: string,) => {


  

  return `/api/inbox/${address}`
}

export const clearInbox = async (address: string, options?: RequestInit): Promise<clearInboxResponse> => {
  
  const res = await fetch(getClearInboxUrl(address),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: clearInboxResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as clearInboxResponse
}
  



export const getClearInboxMutationOptions = <TError = ApiErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearInbox>>, TError,{address: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof clearInbox>>, TError,{address: string}, TContext> => {

const mutationKey = ['clearInbox'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof clearInbox>>, {address: string}> = (props) => {
          const {address} = props ?? {};

          return  clearInbox(address,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ClearInboxMutationResult = NonNullable<Awaited<ReturnType<typeof clearInbox>>>
    
    export type ClearInboxMutationError = ApiErrorResponse

    /**
 * @summary Clear entire inbox
 */
export const useClearInbox = <TError = ApiErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearInbox>>, TError,{address: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof clearInbox>>,
        TError,
        {address: string},
        TContext
      > => {
      return useMutation(getClearInboxMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve all emails for a specific address
 * @summary Get inbox emails
 */
export type getInboxResponse200 = {
  data: ApiInboxResponse
  status: 200
}

export type getInboxResponse400 = {
  data: ApiErrorResponse
  status: 400
}

export type getInboxResponse500 = {
  data: ApiErrorResponse
  status: 500
}

export type getInboxResponseSuccess = (getInboxResponse200) & {
  headers: Headers;
};
export type getInboxResponseError = (getInboxResponse400 | getInboxResponse500) & {
  headers: Headers;
};

export type getInboxResponse = (getInboxResponseSuccess | getInboxResponseError)

export const getGetInboxUrl = (address: string,) => {


  

  return `/api/inbox/${address}`
}

export const getInbox = async (address: string, options?: RequestInit): Promise<getInboxResponse> => {
  
  const res = await fetch(getGetInboxUrl(address),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getInboxResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getInboxResponse
}
  




export const getGetInboxInfiniteQueryKey = (address: string,) => {
    return [
    'infinite', `/api/inbox/${address}`
    ] as const;
    }

export const getGetInboxQueryKey = (address: string,) => {
    return [
    `/api/inbox/${address}`
    ] as const;
    }

    
export const getGetInboxInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getInbox>>>, TError = ApiErrorResponse>(address: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInbox>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInboxInfiniteQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInbox>>> = ({ signal }) => getInbox(address, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInbox>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInboxInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getInbox>>>
export type GetInboxInfiniteQueryError = ApiErrorResponse


export function useGetInboxInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getInbox>>>, TError = ApiErrorResponse>(
 address: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInbox>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInbox>>,
          TError,
          Awaited<ReturnType<typeof getInbox>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInboxInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getInbox>>>, TError = ApiErrorResponse>(
 address: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInbox>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInbox>>,
          TError,
          Awaited<ReturnType<typeof getInbox>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInboxInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getInbox>>>, TError = ApiErrorResponse>(
 address: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInbox>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get inbox emails
 */

export function useGetInboxInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getInbox>>>, TError = ApiErrorResponse>(
 address: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInbox>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetInboxInfiniteQueryOptions(address,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetInboxQueryOptions = <TData = Awaited<ReturnType<typeof getInbox>>, TError = ApiErrorResponse>(address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInbox>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInboxQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInbox>>> = ({ signal }) => getInbox(address, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInbox>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInboxQueryResult = NonNullable<Awaited<ReturnType<typeof getInbox>>>
export type GetInboxQueryError = ApiErrorResponse


export function useGetInbox<TData = Awaited<ReturnType<typeof getInbox>>, TError = ApiErrorResponse>(
 address: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInbox>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInbox>>,
          TError,
          Awaited<ReturnType<typeof getInbox>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInbox<TData = Awaited<ReturnType<typeof getInbox>>, TError = ApiErrorResponse>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInbox>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInbox>>,
          TError,
          Awaited<ReturnType<typeof getInbox>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInbox<TData = Awaited<ReturnType<typeof getInbox>>, TError = ApiErrorResponse>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInbox>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get inbox emails
 */

export function useGetInbox<TData = Awaited<ReturnType<typeof getInbox>>, TError = ApiErrorResponse>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInbox>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetInboxQueryOptions(address,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Delete a specific email by ID for an address
 * @summary Delete single email
 */
export type deleteEmailResponse200 = {
  data: ApiDeleteResponse
  status: 200
}

export type deleteEmailResponse400 = {
  data: ApiErrorResponse
  status: 400
}

export type deleteEmailResponse500 = {
  data: ApiErrorResponse
  status: 500
}

export type deleteEmailResponseSuccess = (deleteEmailResponse200) & {
  headers: Headers;
};
export type deleteEmailResponseError = (deleteEmailResponse400 | deleteEmailResponse500) & {
  headers: Headers;
};

export type deleteEmailResponse = (deleteEmailResponseSuccess | deleteEmailResponseError)

export const getDeleteEmailUrl = (address: string,
    emailId: string,) => {


  

  return `/api/inbox/${address}/${emailId}`
}

export const deleteEmail = async (address: string,
    emailId: string, options?: RequestInit): Promise<deleteEmailResponse> => {
  
  const res = await fetch(getDeleteEmailUrl(address,emailId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteEmailResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteEmailResponse
}
  



export const getDeleteEmailMutationOptions = <TError = ApiErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEmail>>, TError,{address: string;emailId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteEmail>>, TError,{address: string;emailId: string}, TContext> => {

const mutationKey = ['deleteEmail'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEmail>>, {address: string;emailId: string}> = (props) => {
          const {address,emailId} = props ?? {};

          return  deleteEmail(address,emailId,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEmailMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEmail>>>
    
    export type DeleteEmailMutationError = ApiErrorResponse

    /**
 * @summary Delete single email
 */
export const useDeleteEmail = <TError = ApiErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEmail>>, TError,{address: string;emailId: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteEmail>>,
        TError,
        {address: string;emailId: string},
        TContext
      > => {
      return useMutation(getDeleteEmailMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve a specific email by ID for an address
 * @summary Get single email
 */
export type getEmailResponse200 = {
  data: ApiEmailResponse
  status: 200
}

export type getEmailResponse400 = {
  data: ApiErrorResponse
  status: 400
}

export type getEmailResponse404 = {
  data: ApiErrorResponse
  status: 404
}

export type getEmailResponse500 = {
  data: ApiErrorResponse
  status: 500
}

export type getEmailResponseSuccess = (getEmailResponse200) & {
  headers: Headers;
};
export type getEmailResponseError = (getEmailResponse400 | getEmailResponse404 | getEmailResponse500) & {
  headers: Headers;
};

export type getEmailResponse = (getEmailResponseSuccess | getEmailResponseError)

export const getGetEmailUrl = (address: string,
    emailId: string,) => {


  

  return `/api/inbox/${address}/${emailId}`
}

export const getEmail = async (address: string,
    emailId: string, options?: RequestInit): Promise<getEmailResponse> => {
  
  const res = await fetch(getGetEmailUrl(address,emailId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getEmailResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getEmailResponse
}
  




export const getGetEmailInfiniteQueryKey = (address: string,
    emailId: string,) => {
    return [
    'infinite', `/api/inbox/${address}/${emailId}`
    ] as const;
    }

export const getGetEmailQueryKey = (address: string,
    emailId: string,) => {
    return [
    `/api/inbox/${address}/${emailId}`
    ] as const;
    }

    
export const getGetEmailInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getEmail>>>, TError = ApiErrorResponse>(address: string,
    emailId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getEmail>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmailInfiniteQueryKey(address,emailId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmail>>> = ({ signal }) => getEmail(address,emailId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address && emailId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getEmail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEmailInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getEmail>>>
export type GetEmailInfiniteQueryError = ApiErrorResponse


export function useGetEmailInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getEmail>>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getEmail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmail>>,
          TError,
          Awaited<ReturnType<typeof getEmail>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEmailInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getEmail>>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getEmail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmail>>,
          TError,
          Awaited<ReturnType<typeof getEmail>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEmailInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getEmail>>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getEmail>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get single email
 */

export function useGetEmailInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getEmail>>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getEmail>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEmailInfiniteQueryOptions(address,emailId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetEmailQueryOptions = <TData = Awaited<ReturnType<typeof getEmail>>, TError = ApiErrorResponse>(address: string,
    emailId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmail>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmailQueryKey(address,emailId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmail>>> = ({ signal }) => getEmail(address,emailId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address && emailId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEmailQueryResult = NonNullable<Awaited<ReturnType<typeof getEmail>>>
export type GetEmailQueryError = ApiErrorResponse


export function useGetEmail<TData = Awaited<ReturnType<typeof getEmail>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmail>>,
          TError,
          Awaited<ReturnType<typeof getEmail>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEmail<TData = Awaited<ReturnType<typeof getEmail>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEmail>>,
          TError,
          Awaited<ReturnType<typeof getEmail>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEmail<TData = Awaited<ReturnType<typeof getEmail>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmail>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get single email
 */

export function useGetEmail<TData = Awaited<ReturnType<typeof getEmail>>, TError = ApiErrorResponse>(
 address: string,
    emailId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmail>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEmailQueryOptions(address,emailId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Register a derived hex address to receive emails for the next 24 hours
 * @summary Register address for inbound mail
 */
export type registerAddressResponse200 = {
  data: ApiRegisterResponse
  status: 200
}

export type registerAddressResponse400 = {
  data: ApiErrorResponse
  status: 400
}

export type registerAddressResponse500 = {
  data: ApiErrorResponse
  status: 500
}

export type registerAddressResponseSuccess = (registerAddressResponse200) & {
  headers: Headers;
};
export type registerAddressResponseError = (registerAddressResponse400 | registerAddressResponse500) & {
  headers: Headers;
};

export type registerAddressResponse = (registerAddressResponseSuccess | registerAddressResponseError)

export const getRegisterAddressUrl = (address: string,) => {


  

  return `/api/register/${address}`
}

export const registerAddress = async (address: string, options?: RequestInit): Promise<registerAddressResponse> => {
  
  const res = await fetch(getRegisterAddressUrl(address),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: registerAddressResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as registerAddressResponse
}
  



export const getRegisterAddressMutationOptions = <TError = ApiErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerAddress>>, TError,{address: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof registerAddress>>, TError,{address: string}, TContext> => {

const mutationKey = ['registerAddress'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerAddress>>, {address: string}> = (props) => {
          const {address} = props ?? {};

          return  registerAddress(address,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterAddressMutationResult = NonNullable<Awaited<ReturnType<typeof registerAddress>>>
    
    export type RegisterAddressMutationError = ApiErrorResponse

    /**
 * @summary Register address for inbound mail
 */
export const useRegisterAddress = <TError = ApiErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerAddress>>, TError,{address: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerAddress>>,
        TError,
        {address: string},
        TContext
      > => {
      return useMutation(getRegisterAddressMutationOptions(options), queryClient);
    }
