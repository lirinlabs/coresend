# Copilot Instructions for CoreSend

## What is CoreSend?

CoreSend is a **temporary/disposable email service** with identity-based authentication. It provides throwaway email addresses derived from BIP39 mnemonics (12-word seed phrases) and Ed25519 cryptographic key pairs. Users receive a 16-character hex address that serves as their inbox identifier.

## Repository Structure

This is a **Bun monorepo** with two workspaces:

```
coresend/
├── app/               # React frontend (TypeScript, Vite, TailwindCSS v4, React Query)
├── backend/           # Go HTTP+SMTP server (net/http, Redis, go-smtp)
├── caddy/             # Caddyfile for reverse proxy / TLS termination
├── docker-compose.yml # Production stack: Redis + Backend + Caddy
├── docker-compose.override.yml
├── .env.example       # DOMAIN_NAME, REDIS_PASSWORD
└── package.json       # Root monorepo scripts
```

## Tech Stack

### Backend (`backend/`)
- **Language**: Go (`github.com/fn-jakubkarp/coresend` module)
- **HTTP**: standard `net/http` — no third-party router
- **SMTP**: `github.com/emersion/go-smtp`
- **Storage**: Redis (sorted sets for inbox, key expiry for TTL, pipeline for rate limiting)
- **Identity**: Ed25519 keys derived deterministically from BIP39 12-word mnemonics via HMAC-SHA256 seed; 16-char hex address = first 16 hex chars of SHA-256(pubkey)
- **API docs**: Swagger via `github.com/swaggo/swag` — regenerate with `make -C backend swagger`
- **Auth**: Request signing — four headers: `X-Auth-Address`, `X-Auth-Timestamp`, `X-Auth-Pubkey`, `X-Auth-Signature`

### Frontend (`app/`)
- **Framework**: React 19 + TypeScript, bundled with Vite
- **Styling**: TailwindCSS v4 (via `@tailwindcss/vite` plugin), `tw-animate-css`
- **UI primitives**: Radix UI, shadcn/ui conventions (`components.json`)
- **Icons**: Phosphor Icons (`@phosphor-icons/react`), Lucide React
- **Data fetching**: TanStack React Query v5
- **Routing**: React Router v7
- **API client**: generated by Orval from `backend/docs/swagger.yaml` → `app/src/api/generated.ts`
- **Crypto**: `@noble/ed25519`, `@noble/curves`, `@noble/hashes`, `@scure/bip39`
- **Toasts**: Sonner
- **Animations**: GSAP, Motion

## Key Internal Packages

| Package | Path | Purpose |
|---|---|---|
| `identity` | `backend/internal/identity/generator.go` | Mnemonic generation, key derivation, address validation, message signing |
| `store` | `backend/internal/store/redis.go` | `EmailStore` interface + Redis implementation; inbox CRUD, rate limiting |
| `smtp` | `backend/internal/smtp/backend.go` | SMTP backend that saves incoming emails to the store |
| `api` | `backend/internal/api/` | HTTP handlers, auth/rate-limit/CORS/logging middleware, router |

## API Endpoints

All inbox endpoints require the four auth headers and validate that the `{address}` in the path matches the authenticated address.

| Method | Path | Description |
|---|---|---|
| GET | `/api/inbox/{address}` | List all emails (newest first) |
| GET | `/api/inbox/{address}/{emailId}` | Get a single email |
| DELETE | `/api/inbox/{address}/{emailId}` | Delete a single email |
| DELETE | `/api/inbox/{address}` | Clear entire inbox |
| GET | `/api/health` | Health check (Redis + SMTP status) |
| GET | `/docs/` | Swagger UI |

Limits: max 100 emails per inbox, 24-hour TTL. Rate limits: 60 GET/min, 30 DELETE/min (per IP).

## Authentication Flow

### Backend identity (`backend/internal/identity/generator.go`)
1. `DeriveEd25519KeyPair(mnemonic)` derives a 32-byte seed via `HMAC-SHA256(key="coresend-auth", data=mnemonic)` then calls `ed25519.NewKeyFromSeed(seed)`.
2. `AddressFromPublicKey(pubkey)` → `hex(SHA-256(pubkey))[:16]` — **16-character** hex address.
3. `CreateMessageToSign(address, timestamp)` returns `address + "|" + string(rune(timestamp))`.
4. For each protected API request the client must send: `X-Auth-Address`, `X-Auth-Timestamp` (Unix ms), `X-Auth-Pubkey` (hex), `X-Auth-Signature` (Ed25519 hex).

### Frontend identity (`app/src/lib/crypto/deriveIdentityFromMnemonic.ts`)
> ⚠️ The frontend implementation currently diverges from the backend in two ways:
> 1. **Seed derivation**: uses the standard BIP39 `mnemonicToSeedSync` (64-byte seed, first 32 bytes used as private key) rather than the backend's HMAC-SHA256 approach.
> 2. **Address length**: takes `slice(0, 40)` of the hex digest (40 chars / 20 bytes) rather than the backend's 16 chars.
>
> These divergences mean the frontend-derived address will **not** match what the backend expects. The Inbox page currently uses mock data and the live API integration is incomplete; reconciling the identity derivation is a prerequisite before wiring up the real API calls.

## Development Workflow

### Prerequisites
- [Bun](https://bun.sh/) ≥ 1.3
- Go ≥ 1.21
- Redis (local or via Docker)

### Install dependencies
```bash
bun install          # root (installs husky + commitlint)
cd app && bun install  # or: bun install --filter frontend
```

### Backend
```bash
# Run (requires Redis on localhost:6379)
make -C backend run

# Build
make -C backend build           # outputs bin/server

# Test
make -C backend test            # go test -v ./...
make -C backend test-coverage   # + HTML coverage report

# Format
make -C backend fmt             # go fmt ./...

# Lint (requires golangci-lint)
make -C backend lint

# Generate Swagger docs (required before bun run gen)
make -C backend swagger
```

### Frontend
```bash
bun run app:dev       # Vite dev server
bun run app:build     # tsc -b && vite build → app/dist/

# Lint
cd app && bun run lint   # ESLint

# Format
cd app && bun run format:all  # Prettier

# Regenerate API client from Swagger (run make -C backend swagger first)
bun run gen           # = make -C backend swagger && orval
```

### Environment Variables (backend)
| Variable | Default | Description |
|---|---|---|
| `REDIS_ADDR` | `localhost:6379` | Redis address |
| `REDIS_PASSWORD` | _(empty)_ | Redis password |
| `DOMAIN_NAME` | `localhost` | Mail domain |
| `SMTP_LISTEN_ADDR` | `:1025` | SMTP listen address |
| `HTTP_LISTEN_ADDR` | `:8080` | HTTP listen address |
| `SMTP_CERT_PATH` | _(empty)_ | TLS cert for STARTTLS |
| `SMTP_KEY_PATH` | _(empty)_ | TLS key for STARTTLS |

### Docker (full stack)
```bash
cp .env.example .env   # set DOMAIN_NAME
docker compose up -d
```

## Code Style & Conventions

- **Commits**: Conventional Commits enforced via commitlint (`feat:`, `fix:`, `chore:`, etc.)
- **Pre-commit hooks**: lint-staged runs `gofmt -s -w` on Go files and `prettier --write` on frontend files
- **Go**: standard `gofmt`; no framework router — handler registration is in `internal/api/router.go`
- **TypeScript/React**: Prettier + ESLint (with `@tanstack/eslint-plugin-query` and `eslint-plugin-react-hooks`)
- **Frontend components**: follow shadcn/ui conventions; UI primitives live in `app/src/components/ui/`
- **API changes**: always regenerate the Swagger spec (`make -C backend swagger`) and the frontend client (`orval`) together using `bun run gen`

## Testing

- **Backend**: Go tests in `*_test.go` files alongside each package; run with `make -C backend test`. Tests use a mock `EmailStore` (see `handlers_test.go`, `middleware_test.go`, `redis_test.go`).
- **Frontend**: No test suite currently exists.

## Common Pitfalls

- The Go module path is `github.com/fn-jakubkarp/coresend` (not the org name `lirinlabs`); use this path in all Go imports.
- After modifying any Swagger annotations in `backend/cmd/server/main.go` or `backend/internal/api/`, run `make -C backend swagger` to regenerate `backend/docs/`; then run `orval` (or `bun run gen`) to update `app/src/api/generated.ts`.
- The `handleGetInbox` route (`/api/inbox/`) handles GET (list) and — depending on path depth — also GET of a single email and DELETE of a single email. Check `router.go` before adding new routes because the same URL prefix is reused with method differentiation inside the handler.
- `CreateMessageToSign` uses `string(rune(timestamp))` which converts the int64 timestamp to a single Unicode code-point character string, not a decimal string. Any client implementation must replicate this exact (unusual) serialization or authentication will fail.
- Redis sorted-set members are raw JSON strings; `DeleteEmail` re-marshals the email to find the exact member to remove.
- TLS/STARTTLS is optional; if cert/key env vars are missing the server starts without it (logged as a warning, not a fatal error).
