# Copilot Instructions for CoreSend

## What is CoreSend?

CoreSend is a **temporary/disposable email service**. Users receive a 16-character hex address (derived client-side from a BIP39 mnemonic) that serves as their inbox identifier. **All cryptographic operations are intentionally client-side only** — the backend performs no key derivation, mnemonic handling, or signature verification.

## Repository Structure

This is a **Bun monorepo** with two workspaces:

```
coresend/
├── app/               # React frontend (TypeScript, Vite, TailwindCSS v4, React Query)
├── backend/           # Go HTTP+SMTP server (net/http, Redis, go-smtp)
├── caddy/             # Caddyfile for reverse proxy / TLS termination
├── docker-compose.yml # Production stack: Redis + Backend + Caddy
├── docker-compose.override.yml
├── .env.example       # DOMAIN_NAME, REDIS_PASSWORD
└── package.json       # Root monorepo scripts
```

## Tech Stack

### Backend (`backend/`)
- **Language**: Go (`github.com/fn-jakubkarp/coresend` module)
- **HTTP**: standard `net/http` — no third-party router
- **SMTP**: `github.com/emersion/go-smtp`
- **Storage**: Redis (sorted sets for inbox, key expiry for TTL, pipeline for rate limiting)
- **Identity**: All crypto is client-side only (see frontend). The backend stores and routes email by 16-char hex address; it does not derive keys or verify signatures.
- **API docs**: Swagger via `github.com/swaggo/swag` — regenerate with `make -C backend swagger`
- **Auth**: Single header `X-Auth-Address` — the backend checks the address is a valid 16-hex-char format and matches the path; no signature verification.

### Frontend (`app/`)
- **Framework**: React 19 + TypeScript, bundled with Vite
- **Styling**: TailwindCSS v4 (via `@tailwindcss/vite` plugin), `tw-animate-css`
- **UI primitives**: Radix UI, shadcn/ui conventions (`components.json`)
- **Icons**: Phosphor Icons (`@phosphor-icons/react`), Lucide React
- **Data fetching**: TanStack React Query v5
- **Routing**: React Router v7
- **API client**: generated by Orval from `backend/docs/swagger.yaml` → `app/src/api/generated.ts`
- **Crypto**: `@noble/ed25519`, `@noble/curves`, `@noble/hashes`, `@scure/bip39`
- **Toasts**: Sonner
- **Animations**: GSAP, Motion

## Key Internal Packages

| Package | Path | Purpose |
|---|---|---|
| `addr` | `backend/internal/addr/validate.go` | Shared address format validation (`^[a-f0-9]{16}$`) |
| `store` | `backend/internal/store/redis.go` | `EmailStore` interface + Redis implementation; inbox CRUD, rate limiting |
| `smtp` | `backend/internal/smtp/backend.go` | SMTP backend that saves incoming emails to the store; validates 16-hex-char address format |
| `api` | `backend/internal/api/` | HTTP handlers, auth/rate-limit/CORS/logging middleware, router |

## API Endpoints

All inbox endpoints require the `X-Auth-Address` header containing the 16-hex-char inbox address. The backend verifies that it matches the `{address}` path segment — no signature or key verification is performed.

| Method | Path | Description |
|---|---|---|
| GET | `/api/inbox/{address}` | List all emails (newest first) |
| GET | `/api/inbox/{address}/{emailId}` | Get a single email |
| DELETE | `/api/inbox/{address}/{emailId}` | Delete a single email |
| DELETE | `/api/inbox/{address}` | Clear entire inbox |
| GET | `/api/health` | Health check (Redis + SMTP status) |
| GET | `/docs/` | Swagger UI |

Limits: max 100 emails per inbox, 24-hour TTL. Rate limits: 60 GET/min, 30 DELETE/min (per IP).

## Authentication Flow

All crypto is **client-side only**. The backend does not perform key derivation, mnemonic generation, or signature verification.

### Frontend identity (`app/src/lib/crypto/deriveIdentityFromMnemonic.ts`)
1. User enters or generates a BIP39 12-word mnemonic in the browser.
2. `deriveIdentityFromMnemonic(mnemonic)` uses `mnemonicToSeedSync` (64-byte BIP39 seed, first 32 bytes = private key) and `@noble/curves/ed25519` to produce `(privateKey, publicKey, address)`.
3. `address` = `bytesToHex(sha256(publicKey)).slice(0, 40)` — **40 hex chars (20 bytes)**.
4. The address is stored in `sessionStorage` and sent as `X-Auth-Address` on every inbox API request.

> ⚠️ **Known divergence to resolve**: The address derivation algorithm above (BIP39 `mnemonicToSeedSync`, 40-char address) does not yet match the backend's address validation regex (`^[a-f0-9]{16}$`, 16 chars). The frontend must be updated so the address it derives is exactly 16 hex characters, or the backend regex must be updated to match the frontend's output. Reconciling this is a prerequisite for wiring up the live API.

### Backend auth (`backend/internal/api/middleware.go`)
The `authMiddleware` only checks:
1. `X-Auth-Address` header is present.
2. The value matches `^[a-f0-9]{16}$`.
3. The value equals the `{address}` segment of the request path.

## Development Workflow

### Prerequisites
- [Bun](https://bun.sh/) ≥ 1.3
- Go ≥ 1.21
- Redis (local or via Docker)

### Install dependencies
```bash
bun install          # root (installs husky + commitlint)
cd app && bun install  # or: bun install --filter frontend
```

### Backend
```bash
# Run (requires Redis on localhost:6379)
make -C backend run

# Build
make -C backend build           # outputs bin/server

# Test
make -C backend test            # go test -v ./...
make -C backend test-coverage   # + HTML coverage report

# Format
make -C backend fmt             # go fmt ./...

# Lint (requires golangci-lint)
make -C backend lint

# Generate Swagger docs (required before bun run gen)
make -C backend swagger
```

### Frontend
```bash
bun run app:dev       # Vite dev server
bun run app:build     # tsc -b && vite build → app/dist/

# Lint
cd app && bun run lint   # ESLint

# Format
cd app && bun run format:all  # Prettier

# Regenerate API client from Swagger (run make -C backend swagger first)
bun run gen           # = make -C backend swagger && orval
```

### Environment Variables (backend)
| Variable | Default | Description |
|---|---|---|
| `REDIS_ADDR` | `localhost:6379` | Redis address |
| `REDIS_PASSWORD` | _(empty)_ | Redis password |
| `DOMAIN_NAME` | `localhost` | Mail domain |
| `SMTP_LISTEN_ADDR` | `:1025` | SMTP listen address |
| `HTTP_LISTEN_ADDR` | `:8080` | HTTP listen address |
| `SMTP_CERT_PATH` | _(empty)_ | TLS cert for STARTTLS |
| `SMTP_KEY_PATH` | _(empty)_ | TLS key for STARTTLS |

### Docker (full stack)
```bash
cp .env.example .env   # set DOMAIN_NAME
docker compose up -d
```

## Code Style & Conventions

- **Commits**: Conventional Commits enforced via commitlint (`feat:`, `fix:`, `chore:`, etc.)
- **Pre-commit hooks**: lint-staged runs `gofmt -s -w` on Go files and `prettier --write` on frontend files
- **Go**: standard `gofmt`; no framework router — handler registration is in `internal/api/router.go`
- **TypeScript/React**: Prettier + ESLint (with `@tanstack/eslint-plugin-query` and `eslint-plugin-react-hooks`)
- **Frontend components**: follow shadcn/ui conventions; UI primitives live in `app/src/components/ui/`
- **API changes**: always regenerate the Swagger spec (`make -C backend swagger`) and the frontend client (`orval`) together using `bun run gen`

## Testing

- **Backend**: Go tests in `*_test.go` files alongside each package; run with `make -C backend test`. Tests use a mock `EmailStore` (see `handlers_test.go`, `middleware_test.go`, `redis_test.go`).
- **Frontend**: No test suite currently exists.

## Common Pitfalls

- The Go module path is `github.com/fn-jakubkarp/coresend` (not the org name `lirinlabs`); use this path in all Go imports.
- After modifying any Swagger annotations in `backend/cmd/server/main.go` or `backend/internal/api/`, run `make -C backend swagger` to regenerate `backend/docs/`; then run `orval` (or `bun run gen`) to update `app/src/api/generated.ts`.
- The `handleGetInbox` route (`/api/inbox/`) handles GET (list) and — depending on path depth — also GET of a single email and DELETE of a single email. Check `router.go` before adding new routes because the same URL prefix is reused with method differentiation inside the handler.
- **Do not add crypto to the backend.** All cryptographic operations (mnemonic generation, key derivation, address derivation, signing) are intentionally client-side only.
- The address format expected by the backend is `^[a-f0-9]{16}$` (16 lowercase hex chars). The frontend currently derives a 40-char address — this must be reconciled before live API integration.
- Redis sorted-set members are raw JSON strings; `DeleteEmail` re-marshals the email to find the exact member to remove.
- TLS/STARTTLS is optional; if cert/key env vars are missing the server starts without it (logged as a warning, not a fatal error).

